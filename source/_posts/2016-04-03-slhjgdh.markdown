---
layout: post
title: "Swift 学习笔记"
date: 2016-04-03 21:02:07 +0800
comments: true
categories: 
---
###在对象内部直接访问实例变量

- 在对象内部读取数据时，应该通过实例变量来读，而写入数据时，则应通过属性来写。（三个好处）
- 在init方法与dealloc方法中，总是应该通过实例变量来读取数据；
- 使用惰性加载的数据应该通过属性来读取数据。

__

###理解“对象的等同性”这一概念

- == 操作符比较的是两个指针本身;
- 如果isEqual:方法判定两个对象相等，那么其hash方法也必须返回同一个值；
- 如果受测得参数与接收消息的对象都属于同一个类，那么就调用自己编写的判定方法，否则就交由超类来判断；
- 如果把某对象放入set之后又想修改其内容，那么后面的行为很难预料；
- 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同；
- 不要盲目的逐个检测每条属性，而是应该依照具体需求来定制检测方案；
- 编写hash方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。

###以“类族模式”隐藏实现细节

- 基类接口一般都没有名为init的方法，这暗示该类的实例也许不应该由该用户直接创建；
- 如果对象所属的类位于某个基类中，那么在查询其类型信息(instrospection)就要当心；
- Cocoa系统框架有许多类族，大部分collection类都是类族；
- isKindOfClass: 可以用来判断某对象是否位于类族中，不要直接检测两个类对象是否等同；
- 类族可以把实现细节隐藏在一套简单的公共接口背后;
- 系统框架中经常使用类族；
- 从类族的公共抽象基类中继承子类时要当心，若有开发文档，测应先阅读。

###在既有类中使用关联对象存放自定义数据

- 可以通过“关联对象”机制把两个对象连起来；
- 定义关联对象时可以指定内存管理语义，用以模仿定义属性时的”拥有关系”和”非拥有关系”
- 只有在其他做法不可行时才应选用关联对象，因为这种做法会引入难于查找的bug。

###理解objc_msgSend的作用

- 每个类里都有一张表格，其中的指针指向实际的C函数，而选择子的名称则是查表时所用的键；
- 消息由接受者、选择子及参数构成。给某对象“发送消息” ，也就相当于在该对象上调用方法。
- 发给某对象的全部消息都要由“动态消息派发系统”来处理，该系统会查处对应的方法，并执行代码。

###理解消息转发机制

- 若对象无法响应某个选择子，则进入消息转发流程；
- 通过运行期的动态方法解析，我们可以在需要用到某个方法时在将其加入类中；
- 对象可以把其无法解析的某些选择子转交给其他对象来处理；
- 经过上述两步之后，如果还是没办法处理选择子，那就启动完整的消息转发机制。
